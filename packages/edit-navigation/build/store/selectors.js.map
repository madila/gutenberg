{"version":3,"sources":["@wordpress/edit-navigation/src/store/selectors.js"],"names":["getNavigationPostForMenu","select","state","menuId","hasResolvedNavigationPost","getEditedEntityRecord","KIND","POST_TYPE","hasFinishedResolution","getMenuItemForClientId","postId","clientId","mapping","getMenuItem"],"mappings":";;;;;;;AAGA;;AAKA;;AAKA;;AAbA;;;;AAKA;;;;AAKA;;;;AAKA;;;;;;;;;;AAUO,IAAMA,wBAAwB,GAAG,kCACvC,UAAEC,MAAF;AAAA,SAAc,UAAEC,KAAF,EAASC,MAAT,EAAqB;AAClC;AACA;AACA;AACA,QAAK,CAAEC,yBAAyB,CAAEF,KAAF,EAASC,MAAT,CAAhC,EAAoD;AACnD,aAAO,IAAP;AACA;;AACD,WAAOF,MAAM,CAAE,MAAF,CAAN,CAAiBI,qBAAjB,CACNC,WADM,EAENC,gBAFM,EAGN,kCAAuBJ,MAAvB,CAHM,CAAP;AAKA,GAZD;AAAA,CADuC,CAAjC;AAgBP;;;;;;;;AAMO,IAAMC,yBAAyB,GAAG,kCACxC,UAAEH,MAAF;AAAA,SAAc,UAAEC,KAAF,EAASC,MAAT,EAAqB;AAClC,WAAOF,MAAM,CAAE,MAAF,CAAN,CAAiBO,qBAAjB,CAAwC,iBAAxC,EAA2D,CACjEF,WADiE,EAEjEC,gBAFiE,EAGjE,kCAAuBJ,MAAvB,CAHiE,CAA3D,CAAP;AAKA,GAND;AAAA,CADwC,CAAlC;AAUP;;;;;;;;;AAOO,IAAMM,sBAAsB,GAAG,kCACrC,UAAER,MAAF;AAAA,SAAc,UAAEC,KAAF,EAASQ,MAAT,EAAiBC,QAAjB,EAA+B;AAC5C,QAAMC,OAAO,GAAG,oBAAQV,KAAK,CAACU,OAAN,CAAeF,MAAf,CAAR,CAAhB;AACA,WAAOT,MAAM,CAAE,MAAF,CAAN,CAAiBY,WAAjB,CAA8BD,OAAO,CAAED,QAAF,CAArC,CAAP;AACA,GAHD;AAAA,CADqC,CAA/B","sourcesContent":["/**\n * External dependencies\n */\nimport { invert } from 'lodash';\n\n/**\n * WordPress dependencies\n */\nimport { createRegistrySelector } from '@wordpress/data';\n\n/**\n * Internal dependencies\n */\nimport { KIND, POST_TYPE, buildNavigationPostId } from './utils';\n\n/**\n * Returns a \"stub\" navigation post reflecting the contents of menu with id=menuId. The\n * post is meant as a convenient to only exists in runtime and should never be saved. It\n * enables a convenient way of editing the navigation by using a regular post editor.\n *\n * Related resolver fetches all menu items, converts them into blocks, and hydrates a new post with them.\n *\n * @param {number} menuId The id of menu to create a post from.\n * @return {null|Object} Post once the resolver fetches it, otherwise null\n */\nexport const getNavigationPostForMenu = createRegistrySelector(\n\t( select ) => ( state, menuId ) => {\n\t\t// When the record is unavailable, calling getEditedEntityRecord triggers a http\n\t\t// request via it's related resolver. Let's return nothing until getNavigationPostForMenu\n\t\t// resolver marks the record as resolved.\n\t\tif ( ! hasResolvedNavigationPost( state, menuId ) ) {\n\t\t\treturn null;\n\t\t}\n\t\treturn select( 'core' ).getEditedEntityRecord(\n\t\t\tKIND,\n\t\t\tPOST_TYPE,\n\t\t\tbuildNavigationPostId( menuId )\n\t\t);\n\t}\n);\n\n/**\n * Returns true if the navigation post related to menuId was already resolved.\n *\n * @param {number} menuId The id of menu.\n * @return {boolean} True if the navigation post related to menuId was already resolved, false otherwise.\n */\nexport const hasResolvedNavigationPost = createRegistrySelector(\n\t( select ) => ( state, menuId ) => {\n\t\treturn select( 'core' ).hasFinishedResolution( 'getEntityRecord', [\n\t\t\tKIND,\n\t\t\tPOST_TYPE,\n\t\t\tbuildNavigationPostId( menuId ),\n\t\t] );\n\t}\n);\n\n/**\n * Returns a menu item represented by the block with id clientId.\n *\n * @param {number} postId    Navigation post id\n * @param {number} clientId  Block clientId\n * @return {Object|null} Menu item entity\n */\nexport const getMenuItemForClientId = createRegistrySelector(\n\t( select ) => ( state, postId, clientId ) => {\n\t\tconst mapping = invert( state.mapping[ postId ] );\n\t\treturn select( 'core' ).getMenuItem( mapping[ clientId ] );\n\t}\n);\n"]}